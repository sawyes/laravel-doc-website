<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <link rel="shortcut icon" href="assets/ico/favicon.png">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="author" content="@summer">
    <title>Linux 常用命令</title>
    <meta name="description" content="Laravel 5.1 LTS 速查表方便快速浏览，支持并且只支持 Laravel 5.1 LTS，支持手机访问，支持中英文版本">
    <meta name="keywords" content="linux 学习笔记">
    <link rel="stylesheet" href="assets/css2/normalize.css" />
    <link rel="stylesheet" href="assets/css2/foundation.min.css" />
    <link rel="stylesheet" href="assets/css2/font-awesome.min.css" />
    <link rel="stylesheet" href="assets/css2/page.css" />
    <style>
        .code-column h6 {
          color: #3adb76;
        }
    </style>
</head>
<body>

<div class="off-canvas-wrapper wrapper-container">
    <div class="off-canvas-wrapper-inner" data-off-canvas-wrapper>

        <div class="off-canvas position-left sidebar-canvas" id="offCanvasLeft" data-off-canvas data-position="left">
            <button class="close-button" aria-label="Close menu" type="button" data-close>
                <span aria-hidden="true">&times;</span>
            </button>
            <ul class="mobile-ofc vertical menu">
                <li>
                    <button class="warning hollow button check-all-button">查看全部</button>
                </li>
                <li>
                    <ul class="submenu menu vertical mobile-cmd-cell" data-submenu>
                    </ul>
                </li>
            </ul>
        </div>

        <div class="off-canvas-content" data-off-canvas-content>
            <div class="title-bar hide-for-medium">
                <div class="title-bar-left">
                    <button class="menu-icon" type="button" data-open="offCanvasLeft"></button>
                </div>
            </div>
        </div>

        <a href="#top" id="top-button" title="Top"><i class="icon-arrow-up"></i></a>
        <a href="#" class="comments-toggle" title="隐藏/展示代码注释"><i class="icon-eye-close"></i></a>

        <div class="row full-width">

            <div class="large-2 columns code-column sidebar">
                <h5 class="sidebar-title">Linux 常用命令</h5>
                <hr class="horizonal-line">
                <div class="show-for-medium">
                    <button class="warning hollow button check-all-button">查看全部</button>

                    <div class="clearfix"></div>
                    <ul class="sidebar-menu">
                    </ul>

                    <div class="clearfix"></div>

                    <hr class="horizonal-line">
                </div>
                <ul class="sidebar-bottom">
                    <li><a href="https://www.kernel.org/" class="button expand small radius alert">Linux Kernel</a></li>
                </ul>
            </div>
            <div class="large-10 columns code-column code-container">
                <div class="grid">
<!--
<section class="cmd-description grid-item">
<h4><a name="模板" href="#模板">模板</a>
<a target='_blank' href="" title="模板"><i class="icon-file-text"></i></a></h4>

<pre class="prettyprint lang-shell">

</pre>

<h6>模板2 <a target='_blank' href="" title="模板2"><i class="icon-file-text"></i></a></h6>
<pre class="prettyprint lang-shell">
</pre>
</section>
-->
<section class="cmd-description grid-item">
<h4><a name="目录管理" href="#目录管理">目录管理</a>
<h6>查看ls</h6>
<pre class="prettyprint lang-php">
蓝色表示目录；
绿色表示可执行文件；
红色表示压缩文件；
浅蓝色表示链接文件；
白色表示其他文件；
黄色是设备文件，包括block, char, fifo。

-：普通文件 (f)
d: 目录文件
b: 块设备文件 (block)
c: 字符设备文件 (character)
l: 符号链接文件(symbolic link file)
p: 命令管道文件(pipe)
s: 套接字文件(socket)

//list命令
ls -al
// drwxrwxr-x 993 vagrant vagrant 36864 Aug 16 17:03 .npm

type ls
//ls is aliased to `ls --color=auto'
type ll
//ll is aliased to `ls -l --color=auto'
// 用人类能理解的方式输出大小 -h 好多命令都有， 注意大小变为36K
ls -alh
// drwxrwxr-x 993 vagrant vagrant  36K Aug 16 17:03 .npm
</pre>
<h6>mkdir</h6>
<pre>
-p parent
-v 详细过程
// 命令行展开
mkdir -pv /mnt/test/{x/m,y}
</pre>

<h6>tree</h6>
<pre class="prettyprint lang-php">
// 可能需要自行安装
// ubuntu
sudo apt-get install tree
// centos
rpm -qa tree
mkdir /mnt/cdrom
mount /dev/cdrom /mnt/cdrom
rpm -ivh tree-1.5.3-2.el6.i686.rpm
//查看目录结构
tree test
test
├── ac
├── ad
├── bc
└── bd
</pre>

</section>

<section class="cmd-description grid-item">
    <h4><a name="文件管理" href="#文件管理">文件管理</a></h4>

<h6>cp复制</h6>
<pre class="prettyprint lang-php">
cp SRC DEST
-r 递归
-i 覆盖是询问
-f 强制
-a(archive 啊k爱)：归档复制，常用于备份
-L always follow symbolic links in SOURCE
-P never follow symbolic links in SOURCE

// 归档备份, 属性，软连接等全部保留
cp -a /etc /backup/etc-2013-02-28

// 复制文件夹下的内容到另一个文件夹下, 如初始化用户
cp -r /etc/skel/. /home/user1
// 忘了吧,当复制对象下存在目录的时候可以用* 代替.,否则可能报错, 建议用"."复制即可
cp -r /etc/* /home/user1

</pre>
<h6>touch创建文件</h6>
<pre class="prettyprint lang-php">
// 变更文件的变更时间
touch -mt 201701011248 filename
// 其他参数
-a access time
-t time string
-m modify time
-c change time
</pre>
<h6>rm删除文件</h6>
<pre class="prettyprint lang-php">
// redhat中默认是别名，只有root用户是这样
type rm
//rm is aliased to `rm -i'， -i 交互式
// 忽略别名运行命令本身
\rm -fr 1.txt
// 删除文件：rm
  -i  交互
  -f  不用咨询，强制删除
  -r -R 都是递归
rm -fr 1.txt
</pre>
    <h6>stat</h6>
<pre class="prettyprint lang-php">
stat filename
  File: "filename"
  Size: 1965        Blocks: 8          IO Block: 4096   普通文件
Device: fd00h/64768d    Inode: 654681      Links: 1
Access: (0755/-rwxr-xr-x)  Uid: (    0/    root)   Gid: (    0/    root)
Access: 2017-10-27 00:15:26.236270025 +0800
Modify: 2017-10-27 00:15:26.236270025 +0800
Change: 2017-10-27 00:15:26.236270025 +0800
</pre>
</section>

<section class="cmd-description grid-item">
    <h4><a name="环境变量" href="#环境变量">环境变量</a></h4>
    <pre class="prettyprint lang-shell">
// 输出环境变量
printenv
// 更新环境变量, 可以解决man 乱码问题
export LANG=en
// 基于printenv的键，可以直接用变量的方式输出
$PATH
$HISTSIZE
$SHELL 当前用户shell

// 环境变量添加路径
# PATH=$PATH:/tmp

// 输出当前用户环境变量，echo $PATH,如何做到添加变量，添加用户的时候拥有默认环境变量
    </pre>
<h6>hash o(1)<a target='_blank' href="http://blog.csdn.net/wendavidoi/article/details/50670016" title="Artisan CLI @ Laravel Docs"><i class="icon-file-text"></i></a></h6>
<pre>
// 查看命令的命中率
    hash
</pre>
</section>

<section class="cmd-description grid-item">
<h4><a name="快捷键" href="#快捷键">快捷键</a></h4>
<h6>文本查找</h6>
<pre class="prettyprint lang-php">
//man,vim中
/KEYWORD: 向后
n: 下一个
N：前一个
?KEYWORD：向前
n: 下一个
N：前一个

</pre>
<h6>X window中翻屏(黑窗口)</h6>
<pre>
shift + pageup
shift + pagedown
</pre>
</section>

<section class="cmd-description grid-item">
    <h4><a name="date" href="#date">date</a></h4>
    <h6>date 系统时间管理</h6>
<pre class="prettyprint lang-php">
// RTC real time clock 实时时钟
// UTC 时间
 date -u +'%F %T'
// 日期转成时间戳 输出 1508867210
date -d '2017-10-25 01:46:50' +%s
// 时间戳转换为日期
date --date='@1508867210' +'%F %T'
// +8小时
date --date='now +8 hours' +'%F %T'

// 时区+时间戳
TZ='Asia/Shanghai' date --date='@1508867210' +'%F %T' => 上海日期2017-10-25 01:46:50
TZ='Asia/Shanghai' date --date='2017-10-25 01:46:50' +'%s' => 时间戳1508867210
// **给定上海日期字符串，求当时的UTC时间
date --date='TZ="Asia/Shanghai" 2017-11-29 02:22:00' +'%F %T' => 2017-11-28 18:22:00

// 手动设置系统时间
date -s '2017-10-25 01:46:50'

// 查看时区
/usr/share/zoneinfo/
命令tzselect  (man date中有提及tzselect)

// 变更系统时区
man hwclock中有提及,添加TZ变量可以覆盖系统设置的时区
$ TZ=Asia/Shanghai
$ export TZ
$ PATH=$PATH:$TZ

</pre>
    <h6>hwclock 时间校准</h6>
<p>硬件时钟 clock  由电池纽扣控制</p>
<p>系统时钟 date   由系统控制， 但是CPU可能繁忙导致时间出错</p>
<pre class="prettyprint lang-php">
hwclock -w
// Set the System Time from the Hardware Clock
hwclock -s
// Set the Hardware Clock to the current System Time
</pre>
    <h6>cal日历</h6>
<pre class="prettyprint lang-php">
cal
cal 2012
cal 02 2012
</pre>
</section>

<section class="cmd-description grid-item">
    <h4><a name="alias" href="#alias">alias</a></h4>

<pre class="prettyprint lang-php">
永久生效 vim ~/.bashrc
// alias 是bash命令，只在bash生命周期内有效
// 临时别名，存储当前会话
alias etc='cd /etc'
// 永久写入文件
vim ~/.bashrc
// 立刻生效
source ~/.bash
// 查看所有命令
alias

// 为什么source后才能生效？ 因为alias在登录的时候已经加载到内存，此时是无法知道配置修改
</pre>
</section>

<section class="cmd-description grid-item">
    <h4><a name="文本处理" href="#文本处理">文本处理</a></h4>
    <h6>printf</h6>
<pre class="prettyprint lang-php">
printf "hello, %s\r\n" world
//hello, world
printf "float %.2f\r\n" 1.11911
//float 1.12
</pre>
<h6>tr</h6>
<pre>
// 默认为交互式，同时出现 ab转换AB
tr 'ab' 'AB'
// 结合重定向, 逐个字符比较，替换为大写
tr 'a-z' 'A-Z' < /etc/passwd
// 出现字符a或者b都会删除
tr -d 'ab'
</pre>
</section>

<section class="cmd-description grid-item">
    <h4><a name="查看文本" href="#查看文本">查看文本</a></h4>
<h6>cat、tac、more、less、head、tail</h6>
    <h6>cat || tac</h6>
<pre class="prettyprint lang-php">
-n 行号
-E 显示结束符
-a 显示特殊符号

// 可以连接多个文件
cat 1.txt 2.txt

// 和egrep结合，过滤空行和#开头的字符
// 理解^$为什么是空行？因为linux空行就是只有一个$结束符号，用-E命令可以理解
cat httpd.conf | egrep -v '^$|#'
</pre>
<h6>more 翻屏</h6>
<pre>
backspace 向后一页
b 向前一页
</pre>
<h6>less 用得最多</h6>
<pre>
// 支持搜索，翻到最后不退出， man命令就是less打开的
backspace 向后一页
b 向前一页
</pre>
<h6>tail | head</h6>
<pre>
-n 显示多少行
tail -f: 查看文件尾部，不退出，等待显示后续追加至此文件的新内容；

第9行数据
head -9 /etc/inittab | tail -1

倒数第9行
tail -9 /etc/inittab | head -1

</pre>
<h6>cut</h6>
<pre>
-d delimiter 分隔符,默认为空格
-f field 制定要显示字段
// 冒号作为分隔符，截取第一个字段
cut -d : -f 1 /etc/passwd
// -f1,3  显示1,3字段
// -f1-3  显示1到3个字段
</pre>
<h6>sort</h6>
<pre>
// 默认ascii字符排序
-r 逆序
-n 按数值大小排序
-t, --field-separator=SEP字段分隔符
-k key=pos1,pos2第几个位置作为排序依据
-u uniq 去重
-f 排序忽略字符大小写
// :分割passwd , 以第三个字段逆序输出
sort -t: -k3 -r /etc/passwd
// 按照文件大小排序
ll -h| sort -nk5
</pre>
<h6>uniq</h6>
<pre>
//相邻重复的行才认为是重复的行
-c 重复的次数
-d 只显示重复的行，去重后的值
-D  显示重复的行的所有内容
</pre>
<h6>wc</h6>
<pre>
// word count, 默认显示格式
行 单词数 字节数
-c, --bytes 输出字节数统计
-m, --chars 输出字符数统计
-l, --lines 输出行数统计
</pre>
</section>
<section class="cmd-description grid-item">
    <h4><a name="查看版本" href="#查看版本">查看版本</a></h4>
    <h6></h6>
<pre class="prettyprint lang-php">
lsb_release
cat /etc/lsb-release
cat /etc/issue
cat /proc/version
uname -a
</pre>
</section>
<section class="cmd-description grid-item">
    <h4><a name="bash" href="#bash">bash</a></h4>
<h6>光标跳转：</h6>
<pre>
Ctrl+a：跳到命令行首
Ctrl+e：跳到命令行尾
Ctrl+u: 删除光标至命令行首的内容
Ctrl+k: 删除光标至命令行尾的内容
Ctrl+l: 清屏
Ctrl+d: 向后删除一个字符
</pre>
<h6>命令历史：</h6>
<pre>
查看命令历史：history
-c：清空命令历史
-d OFFSET [n]: 删除指定位置的命令
-w：保存命令历史至历史文件中

// 执行history中制定行号的命令,感叹号
!890
// 执行倒数第四条命令
!-4
// 执行上一条命令
!!
// !+ 字符串，执行命令历史中最近一个指定字符串开头的命令
!ls
// 引用前一个命令的最后一个参数
cat /etc/httpd/conf/http.conf
vim !$
// 获取钱一个命令的最后一个参数到终端
按 ESC 然后按 .
cat /etc/httpd/conf/httpd.conf
vim 按 ESC 然后按
</pre>
<h6>shell的类型</h6>
<pre>
登录式shell:
    正常通常某终端登录
    su - USERNAME
    su -l USERNAME
/etc/profile --> /etc/profile.d/*.sh --> ~/.bash_profile --> ~/.bashrc --> /etc/bashrc(全局shell)

非登录式shell:
    su USERNAME  （半切换）
    图形终端下打开命令窗口
    自动执行的shell脚本
~/.bashrc --> /etc/basrc --> /etc/profile.d/*.sh
没读取/etc/profile，~/.bash_profile
</pre>
<h6>bash的配置文件</h6>
<pre>
// 默认创建的用户shell都是来自于/etc/skel配置
// .bash_logout   .bashrc  .gnome2
// .bash_profile  .emacs   .mozilla

全局配置
    /etc/profile, /etc/profile.d/*.sh(所有文件), /etc/bashrc
个人配置
    ~/.bash_profile, ~/.bashrc

profile类的文件：设定环境变量，登录前运行命令或脚本，全局和个人都有的时候以个人为准

bashrc类的文件：设定本地变量，定义命令别名(alias)

// 编写profile，登录的时候执行脚本输出hello world
vim ~/.bash_profile
    echo "hello world!"
</pre>
</section>
<section class="cmd-description grid-item">
    <h4><a name="命令替换" href="#命令替换">命令替换</a></h4>
<pre>
bash支持的引号：
``: 命令替换
"": 弱引用，可以实现变量替换
'': 强引用，不完成变量替换
</pre>
<H6>$(COMMAND)</H6>
<pre class="prettyprint lang-php">
echo "current path is $(pwd)"
// current path is /etc/httpd/conf
touch ./file-$(date +%F).txt
</pre>
<h6>反引号命令替换`COMMAND`</h6>
echo "current path is `pwd`"
</section>
<section class="cmd-description grid-item">
    <h4><a name="通配符" href="#通配符">通配符</a></h4>
    <h6>man 7 glob</h6>
<pre class="prettyprint lang-php">
*: 任意长度的任意字符
?：任意单个字符
[]：匹配指定范围内的任意单个字符
[abc], [a-m], [a-z], [A-Z], [0-9], [a-zA-Z], [0-9a-zA-Z]
[:space:]：空白字符
[:punct:]：标点符号
[:lower:]：小写字母
[:upper:]: 大写字母
[:alpha:]: 大小写字母
[:digit:]: 数字
[:alnum:]: 数字和大小写字母

# man 7 glob
[^]: 匹配指定范围之外的任意单个字符
// 字母开头中间有空格非字母结尾
ls [[:alpha:]]*[[:space:]]*[^[:alpha:]]
</pre>
</section>

<section class="cmd-description grid-item">
<h4><a name="管道" href="#管道">管道</a></h4>
<pre>
把前一个命令的输出当做后一个命令的输入
命令1 | 命令2 | 命令3

// 输出内容全部大写
echo "hello world" | tr "a-z" "A-Z"

// 标准输入修改密码
echo "passwd" | passwd --stdin user1

// 统计用户数
wc -l /etc/passwd | cut -d' ' -f1
</pre>
<h6>tee</h6>
<pre>
既能输出到屏幕，也能保存到文件
echo "hello world" > tee hello.txt

// 取出密码文件倒数第9行的用户名和shell路径保存文件并输出
tail -9 /etc/passwd | head -1|cut -d: -f1,7| tee /tmp/user.out
</pre>
</section>

<section class="cmd-description grid-item">
<h4><a name="grep" href="#grep">grep</a></h4>
<h6>内容查找</h6>
<pre class="prettyprint lang-php">
grep:
-i 不区分大小写
-r -R 递归
-n 显示行号
-E 等同于egrep, 扩展正则表达式
-F 等同于fgrep, 不支持正则表达式，因而速度非常快
--color 添加颜色
-v 过滤（反向查找），显示没有被模式匹配到的行
-o 紧显示被匹配到的字符串，不会显示行
-A 匹配内容后的行数也显示

正则
*
?
[]
[^]

匹配次数（默认贪婪模式）
. : 匹配任意单个字符
* ：表示匹配前面一个字符出现任意次，甚至是0次
.* : 表示任意字符,任意次数,包括空格
? : 匹配前一个字符一次或0次
\{m,n\} : 匹配前一个字符次数范围
^ : 以字符开头
$ ：以字符结束
^$ : 空白字符
\(\) : 分组，捕获
记忆法\<content\>
\<: \<content 以content开头的单词
\>: content\> 以content结尾的单词

贪婪模式，匹配结果尽可能的长
非贪婪模式，匹配结果尽可能的短

// 有分号和没分号的区别
实例文件匹配 httpd.conf
// 贪婪模式
ls | grep htt*  > 输出文件httpd.conf， 匹配httpd.conf
// 非贪婪模式
ls | grep 'htt*' > 输出文件httpd.conf， 匹配httpd

// 默认是贪婪模式
grep h.*p httpd.conf
等同于
grep 'h.*p' httpd.conf
类似于（不能匹配标点[[:punct:]]  man 7 glob）
grep 'ht[[:alnum:]]*p' httpd.conf
// 匹配1或0个t
grep 'htt\?p' httpd.conf
// 匹配至少1个t
grep 'htt\{1,\}pd' httpd.conf
// 找出以ly结尾的单词
cat httpd.conf | grep 'ly\>'
// 找出以ly开始的单词
cat httpd.conf | grep '\bly'
// 捕获
cat httpd.conf | grep '\(h.*p\).*\1d'


// grep 颜色
vim ~/.bashrc
alias grep='grep --color'
// 文件内容查找
grep root /etc/passwd
// 忽略大小写递归查找文本内容vhost*, 显示匹配的文件，以及内容所在行号
grep -rin vhost* .
// 匹配内容，并且加上后面两行
grep -A 2 '^cache' /proc/cpuinfo
// 前两行
grep -B 2 '^cache' /proc/cpuinfo
// 前后两行
grep -C 2 '^cache' /proc/cpuinfo

// 匹配ip地址
alias ipaddr="egrep --color '(\<([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\>\.){3}\<([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\>'"
ifconfig | ipaddr



练习：
1、显示/proc/meminfo文件中以不区分大小的s开头的行；
grep -i '^s' /proc/meminfo
grep '^[sS]' /proc/meminfo
2、显示/etc/passwd中以nologin结尾的行;
grep 'nologin$' /etc/passwd

取出默认shell为/sbin/nologin的用户列表
grep "nologin$' /etc/passwd | cut -d: -f1

取出默认shell为bash，且其用户ID号最小的用户的用户名
grep 'bash$' /etc/passwd | sort -n -t: -k3 | head -1 | cut -d: -f1

3、显示/etc/inittab中以#开头，且后面跟一个或多个空白字符，而后又跟了任意非空白字符的行；
grep "^#[[:space:]]\{1,\}[^[:space:]]" /etc/inittab

4、显示/etc/inittab中包含了:一个数字:(即两个冒号中间一个数字)的行；
grep ':[0-9]:' /etc/inittab

5、显示/boot/grub/grub.conf文件中以一个或多个空白字符开头的行；
grep '^[[:space:]]\{1,\}' /boot/grub/grub.conf

6、显示/etc/inittab文件中以一个数字开头并以一个与开头数字相同的数字结尾的行；
grep '^\([0-9]\).*\1$' /etc/inittab
</pre>
<h6>忽略空行和注释</h6>
<pre>
// 空行的真谛，默认地linux结尾为$
 cat -E httpd.conf
 因而^$就表示空行了

egrep -v "#|^&" /etc/httpd/conf/http.conf
cat /etc/httpd/conf/http.conf | egrep -v "#|^$"
cat /etc/httpd/conf/http.conf | grep -vEn "#|^$"
</pre>
</section>

<section class="cmd-description grid-item">
    <h4><a name="find" href="#find">find</a></h4>
<h6>基础</h6>
<pre class="prettyprint lang-php">
find path -name "regexp"
find 查找路径 查找标准 查找到以后的处理运作
查找路径：默认为当前目录
查找标准：默认为指定路径下的所有文件
处理运作：默认为显示
</pre>

<h4>时间范围</h4>
<pre>
-mtime n file's data was last modified n*24 hours ago
-ctime n file's  status  was  last  changed  n*24 hours ago.
-atime
    [+|-]#
-mmin
-cmin
-amin
    [+|-]#
</pre>
<h4>权限</h4>
<pre>
-executable
-readable
-print
Search for files which are executable but not readable.
find /sbin /usr/sbin -executable \! -readable -print
</pre>
<h4>实例</h4>
<pre>
1、查找/var目录下属主为root并且属组为mail的所有文件；
find /var -user root -group mail

2、查找/usr目录下不属于root,bin,或student的文件；
find /usr -not -user root -a -not -user bin -a -not -user student
find /usr -not \( -user root -o -user bin -o -user student \)

3、查找/etc目录下最近一周内内容修改过且不属于root及student用户的文件；
find /etc -mtime -7 -not \ ( -user root -o -user student \)
find /etc -mtime -7 -not -user root -a -not -user student


4、查找当前系统上没有属主或属组且最近1天内曾被访问过的文件，并将其属主属组均修改为root；
find / \( -nouser -o -nogroup \) -a -atime -1 -exec chown root:root {} \;

5、查找/etc目录下大于1M的文件，并将其文件名写入/tmp/etc.largefiles文件中；
find /etc -size +1M >> /tmp/etc.largefiles

6、查找/etc目录下所有用户都没有写权限的文件，显示出其详细信息；
find /etc -not -perm /222 -ls
</pre>


</section>

<section class="cmd-description grid-item">
    <h4><a name="xargs" href="#xargs">xargs</a></h4>
    <h6></h6>
<pre class="prettyprint lang-php">
find / -size +100M | xargs {} > /tmp/large.file
</pre>
</section>

<section class="cmd-description grid-item">
    <h4><a name="locate" href="#locate">locate</a></h4>
    <h6></h6>
<pre class="prettyprint lang-php">
非实时,根据系统数据进行查找

updatedb 更新数据库索引, 默认地最近创建的文件无法查找, 所以必须先得索引

locate -A 搜索所有
locate -b redis 字符匹配 搜索文件名含有redis的文件(不是路径)
locate --regexp 'etc.*redis.*f' 正则匹配
locate -i REDIS 忽略大小写匹配
locate -e redis.conf 仅显示locate数据库中存在,同时文件在系统中也存在的文件
</pre>
</section>

<section class="cmd-description grid-item">
    <h4><a name="权限管理" href="#权限管理">*权限管理</a></h4>
<h6>umask</h6>
<pre>
umask 遮罩码

linux哲学思想，文件默认不能有执行权限

管理员默认遮罩码：022
普通用户： 002
如果文件一旦计算存在执行权限，默认+1

umask 022 我的文件其他人只能读
touch abc.file  666-022 = 644 rw-r--r--（777-022=755=744，有1组成的全部去掉）

umask 023 我的文件其他人只能读
touch qq.file   666-023 = 643+1 rw-r--r--

umask 027 同组才能读
umask 002 其他人只能读，同组权限全款

那么普通用户是怎么确认到这个umask的？即默认的创建文件权限
vim /etc/bashrc 这个时候就看见了umask的设定代码
根据登录shell的bash加载流程图，先加载全局的/etc/bashrc，可以看出了系统的实现
</pre>
<h6>chown</h6>
<pre>
// 属主
chown -R username /path
// 属组
chown -R :groupname /path
// 同时修改
chown -R username:groupname /path
</pre>
<h6>chgrp</h6>
<pre>
chgrp groupname filename
</pre>
<h6>chmod</h6>
<pre>
修改用户权限,3种表达方式

chmod -R 755 /path

chmod u=rwx /path
chmod g=rw /path
chmod o=rx /path
chmod g=r,o=w /path
chmod go=rx /path

chmod u-x,g+x /path

suid 不到最后使用suid
chmod u+s /bin/cat
-rwsr-xr-x 1 root root 52080 Feb 18  2016 cat*
/usr/bin/passwd 是特殊场景
如果文件本身就有执行权限, 那么suid显示为s, 否则S

guid 非常有用的知识点
// 指定目录为guid权限, 则目录内创建的任何文件都为上级的属组
chmod g+ws /home/project/log
chown :logger /home/project/log
// 追加用户到同一个附加组, 此时log文件夹下所有创建的文件都是logger组
usermod -a -G loger hadoop
usermod -a -G loger hive
usermod -a -G loger hbase

// sticky 和guid结合使用,否则创建文件不会有相同的组
// 表示一个公共目录中任何人都可以创建删除自己的文件, 但是不能删除别人的文件
chmod o+t /home/project/log


</pre>
<h6>基础</h6>
<pre class="prettyprint lang-php">
权限：
r, w, x

文件：
r：可读，可以使用类似cat等命令查看文件内容；
w：可写，可以编辑或删除此文件；
x: 可执行，exacutable，可以命令提示符下当作命令提交给内核运行；

目录：
r: 可以对此目录执行ls以列出内部的所有文件；
w: 可以在此目录创建文件；
x: 可以使用cd切换进此目录，也可以使用ls -l查看内部文件的详细信息；

rwx:
r--:只读
r-x:读和执行
---：无权限

u: 属主 owner user
g: 属组 group
o：其他 other
</pre>
<h6>特殊文件</h6>
<pre>
// 理论上任何人都可以查看passwd
用户：UID, /etc/passwd
-rw-r--r-- 1 root root 2109 Apr  6  2017 /etc/passwd
组：GID, /etc/group

// 事实上，用户信息保存在passwd，密码用x代替，保存在shadow
影子口令：
用户：/etc/shadow
-rw-r----- 1 root shadow 1217 Apr  6  2017 /etc/shadow
组：/etc/gshadow
用户类别：
管理员：0
普通用户： 1-65535
    系统用户：1-499
    一般用户：500-60000

man 5 passwd
account: 登录名
password: 密码
UID：
GID：基本组ID
comment: 注释
HOME DIR：家目录
SHELL：用户的默认shell

cat /etc/shells 登录可用安全shell
# /etc/shells: valid login shells
/bin/sh
/bin/dash
/bin/bash
/bin/rbash
/usr/bin/tmux
/usr/bin/screen

/etc/shadow
account: 登录名
encrypted password: 加密的密码

用户组类别：
私有组：创建用户时，如果没有为其指定所属的组，系统会自动为其创建一个与用户名同名的组
基本组：用户的默认组
附加组，额外组：默认组以外的其它组

加密方法：
对称加密：加密和解密使用同一个密码，速度是公钥1000倍，效率快
公钥加密（非对称加密）：每个密码都成对儿出现，一个为私钥(secret key)，一个为公钥(public key)
单向加密(指纹加密)，散列加密：提取数据特征码，常用于数据完整性校验
    1、雪崩效应
    2、定长输出
        MD5：Message Digest, 信息摘要,128位定长输出
        SHA1：Secure Hash Algorithm, 160位定长输出


</pre>
<h6>md5加密</h6>
<pre>
md5sum /etc/inittab
753a386bcd9ab0ca581056348463891e  inittab
</pre>

</section>

<section class="cmd-description grid-item">
    <h4><a name="用户管理" href="#用户管理">*用户管理</a></h4>
<h6>添加用户</h6>
<pre>
默认情况下新建用户只能在home目录有操作权限, 如果手动创建的目录, 请注意要chown给予用户权限

// 添加一个用户，默认地添加到tom组
useradd tom
// 查看密码
cat /etc/shadow | grep tom
// tom:!!:17470:0:99999:7:::
// 可以看见是没有密码的，添加一个密码
passwd tom
// 查看密码和私有组
cat /etc/shadow /etc/group | grep tom


为什么会有默认值？
// 查看模板
vim /etc/default/useradd
# useradd defaults file
GROUP=100
HOME=/home
INACTIVE=-1 #密码过期可宽限天数
EXPIRE=     #没指定永不过期
SHELL=/bin/bash
SKEL=/etc/skel
CREATE_MAIL_SPOOL=yes

useradd  [options]  USERNAME
    -u UID 大于等于500，一般和私有组gid相同
    -g GID（基本组）注意不是私有组，用户只有一个基本组，但是可以拥有多个附加组
    -G GID,...  （附加组）重点，附加组只能去/etc/group才能体现
    -c "COMMENT"
    -d /path/to/directory 重点
    -s SHELL 如/bin/bash
    // 复制/etc/skel初始化骨架，如bash_profile bashrc等，即便不带参数也会复制过去
    -m -k
    //  man这个- m参数，发现这个文件/etc/login.defs设置了密码加密算法，过期时间，uid，用户环境变量 ,必须设置家命令等等一些列默认值
    -M  这个参数一出，肯定没有家目录，可以复制/etc/skel初始化骨架
    -r: 添加系统用户 id 1-499,通常没有家目录

useradd -u 1000 user1
//添加user2,指定基本组为grp1, 附加组为grp1, 此时此刻user2的id为1001
useradd -g grp1 -G user1 user2
id user2
tail -2 /etc/group
// user1:x:1000:user2
// grp1:x:1001:
// 禁止用户登录
useradd -s /bin/nologin user3
useradd -M nologindefs
su - nologindefs
// su: 警告：无法切换到目录/home/nologindefs: 没有那个文件或目录
// -bash-4.1$
// 修复此类登录问题，其实是缺少了一些默认的配置，复制/etc/skel的隐藏文件到其家目录即可


// 基本查看useradd路径
which useradd
ll $(which useradd)
ll `which useradd`
// 别名adduser
ll `which adduser`
lrwxrwxrwx. 1 root root 7  8月 17 2015 /usr/sbin/adduser -> useradd
</pre>
<h6>修改密码</h6>
<pre>
// 输入两次用户密码
passwd tom

--stdin  // 管道方式变更密码
    -l 锁定用户
    -u 解锁用户
    -d: 删除用户密码，默认是禁止空密码用户登录

shell 改变密码
echo "redhat" | passwd --stdin user1

</pre>
<h6>openssl生成安全密码</h6>
<pre>
// 输出复制密码
openssl passwd
// 查看密码相关使用手册
man sslpasswd
//  -1  Use the MD5 based BSD password algorithm 1.
// salt加密
openssl -l -salt '123456'

将上述代码复制到shadow即可手动添加密码
</pre>
<h6>修改用户</h6>
<pre>
usermod
    -u UID
    -g GID
    -a -G GID：不使用-a选项，会覆盖此前的附加组；
    -c comment
    -d -m：变更家目录那么原本目录的数据就不能访问了，所以-m就会迁移数据到新目录
    -s shell
    -l 登录名login name ,登录用户名也变更了
    -L：锁定帐号
    -U：解锁帐号

usermod -u 2000 user1

// 为用户user1添加附加组grp2
usermod -a -G grp2 user1
</pre>
<h6>chsh 修改用户默认shell</h6>
<pre>
finger user1
chsh user1
  /bin/csh
// 默认的shell变更了
finger user1
</pre>
<h6>pwck</h6>
<pre>
密码安全隐患报告
</pre>
<h6>修改用户基础信息</h6>
<pre>
// 交互式补全用户基础信息，用户名，电话，公司等，其实就是注释信息的内容
chfn user1
</pre>
<h6>删除用户</h6>
<pre>
注意
// 默认情况下是不会删除用户的家目录
userdel user1
// 删除家目录
userdel -r user1
</pre>
<h6>id 查看用户属性</h6>
<pre>
id user2
// uid=1001(user2) gid=1001(grp1) 组=1001(grp1),1000(user1)

// 附加组id
id -G
// 把附加组id转换成名字，n参数可以和多个id参数配合
id -Gn
</pre>
<h6>finger 用户信息，登录时间，计划任务等</h6>
<pre>
// rpm -qa | grep finger
finger user1
</pre>
</section>
<section class="cmd-description grid-item">
<h4><a name="sticky" href="#sticky">sticky</a></h4>
<pre class="prettyprint lang-php">
在一个公共目录,每个用户都可以创建文件, 删除自己的文件, 但是不能删除别人的文件
chmod o+t /dir
chmod o-t /dir
</pre>
</section>

<section class="cmd-description grid-item">
    <h4><a name="计算器" href="#计算器">计算器</a></h4>
    <h6>bc</h6>
<pre class="prettyprint lang-php">
// 保留两位小数
scale 2
//退出
quit

// shell 中bc计算
echo "scale=2;22/3;" | bc
等同于 bc <<< "scale=2;22/3;"
</pre>
</section>

<section class="cmd-description grid-item">
    <h4><a name="组管理" href="#组管理">组管理</a></h4>
<h6>添加组</h6>
<pre>
groupadd mygroup
  -g 指定gid
  -r 添加一个系统用户 1-499id
</pre>
<h6>修改组</h6>
<pre>
groupmod
  -g GID
  -n GROUPNAME
</pre>
<h6>删除组</h6>
<pre>
groupdel
</pre>
<h6>组密码</h6>
<pre>
gpasswd 为组设定密码
// 应用场景，用户临时切换其他组以获得对应资源，注意原本这个组不属于该用户，否则是可以不输入密码立刻切换的
// 该命令是一种登录属性，使用exit即可退出切换组
// 为用户user1添加附加组grp2
usermod -a -G grp2 user1
newgrp mygroup

// 这个时候就要为gpasswd添加密码了
// 切换组以后创建一个文件,发现组的名称变更了为mygroup，因为基本组已经切换了
touch mygroup.txt
</pre>
</section>
<section class="cmd-description grid-item">
    <h4><a name="CPU" href="#CPU">CPU</a></h4>
<pre class="prettyprint lang-php">
CPU ：加法器，控制器
CPU主频 = 外频 * 倍频
一般说的超频说的就是外频，100MHz外频表示数字脉冲信号在每秒震荡1亿次
倍频一般给厂家锁定了
FSB前端总线，连接CPU和北桥，100Mhz前端总线和64位CPU表示 100M * 64 / 8 bit / 1s= 800MB/s的数据交换速度

机器语言（二进制）：不同芯片平台代码可能需要移植
微码（汇编语言）：微码是芯片自带的，需要编译器编译为二进制
高级语言：理论上，先编译为微码， 然后再编译为二进制
实际上： 高级语言调用汇编的库API，从而忽略芯片的差异

解析型&编译型
解析型
有专门的编译器，一遍编译一次执行，一般效率慢，移植性高
编译型
执行前需要将代码编译成机器码，一次编译永久执行

静态语言&动态语言
静态语言
数据类型在编译期间检查，也就是说写程序的时候要声明所有变量的数据类型，如C/C++, JAVA等
动态语言
运行期间才会检查数据类型的语言，也就是说永远都不需要检查语言的数据类型，如:php, python , javascript, ruby 等

强类型&弱类型
强类型
数据类型一旦定义，必须经过强转换才能改变类型，如：string 3不可能和int 3相加
弱类型
数据类型可以忽略


</pre>

</section>

<section class="cmd-description grid-item">
    <h4><a name="IO重定向" href="#IO重定向">IO重定向</a></h4>
    <h6>系统设定</h6>
<pre class="prettyprint lang-php">
默认输出设备：标准输出，STDOUT, 1
默认输入设备：标准输入, STDIN, 0
标准错误输出：STDERR, 2
</pre>

<h6>重定向</h6>
<pre>
>: 覆盖输出
>>：追加输出

set -C 关闭覆盖输出,禁止对已存在文件使用覆盖输出
// 禁用强制开启,|。如：echo test >| test.log

set +C 开启关闭覆盖输出

2> 错误重定向输出
2>>追加错误重定向输出

&> 重定向正常输出和错误输出
&>> 追加重定向


<  输入重定向
<< heredoc
// 大多数这种命令就是输入重定向
cat < /etc/fstab
// 交互式输入转换大小写，输入重定向后变为直接转换
tr 'a-z' 'A-z' < /etc/fstab

输入输出重定向，脚本中经常使用
cat >> 2017-08.log << EOF
>abc
>EOF
</pre>
</section>


<section class="cmd-description grid-item">
    <h4><a name="shell编程" href="#shell编程">shell编程</a></h4>
脚本在执行时会启动一个子shell进程；
    命令行中启动的脚本会继承当前shell环境变量；
    系统自动执行的脚本(非命令行启动)就需要自我定义需要各环境变量；

<h6>本地变量</h6>
<pre class="prettyprint lang-php">
// 引用变量, 大花括号， ${VAR_NAME}, 大多数时候可以省略
// 双引号弱引用，内部的变量会引用
// 单引号强引用，内部变量不会引用
// 本地变量仅用于当前bash
# name=peter
# echo $name
# echo "my name is $name"
// 区分变量
# echo "my name is ${name}wu"  //my name is peterwu
// 本地变量
#  echo 'my name is ${name}wu' //my name is ${name}wu

</pre>
<h6>局部变量</h6>
<pre>
紧作用于当前代码段
local var_name=test
</pre>
<h6>环境变量</h6>
<pre>
// 导出环境变量
export VARNAME=VALUE

// 原本变量作用域只能存在于当前的shell,export变量使其可以切换bash后保持变量
name=peter
export name
bash
echo $name
</pre>
<h6>位置变量</h6>
<pre>
// 获取脚本运行参数值
$1,$2,$3
</pre>

<h6>特殊变量</h6>
<pre>
$?: 上一个命令的执行状态返回值；
$#：参数的个数
$*: 参数列表
$@：参数列表

程序执行，可能有两类返回值：
    程序执行结果
    程序状态返回代码（0-255）
        0: 正确执行
        1-255：错误执行，1，2，127系统预留；
</pre>

<h6>变量重新赋值</h6>
<pre>
# PERSON=peter
# PERSON=$PERSON:10
// result: peter:10
# echo $PERSON
// 环境变量添加路径
# PATH=$PATH:/tmp
</pre>

<h6>shebang魔数</h6>
<pre>
#!/bin/shell
</pre>
<h6>运算</h6>
A=2
B=3
C=$A+$B
echo $C // 2+3 字符串
<h6>输出重定向</h6>
<pre>
/dev/null: 软件设备， bit bucket，数据黑洞
>
>>
2>
2>>
&>

// 判断用户是否存在
id student &> /dev/null
echo $?
</pre>
<h6>删除变量</h6>
<pre>
// 撤销变量，而不是变量的值
unset name
</pre>
<h6>查看变量</h6>
<pre>
// shell中的变量
set
// shell中的环境变量
printenv
env
export
</pre>
<h6>自动展开</h6>
<pre>
echo {1..4} // 等同于seq
mkdir -p /tmp/{1,b,c,d}
</pre>
<h6>seq</h6>
<pre>
seq 4 // 1 2 3 4
seq 2 4 // 2 3 4
seq 2 2 10 // 2 4 6 8 10
seq 1 2 10 // 1 3 5 7 9
</pre>
</section>
<section class="cmd-description grid-item">
<h4>
    <a name="登陆日志" href="#登陆日志">登陆日志</a>
</h4>
<pre>
    黑客最后要干的事情就是清除登陆日志
</pre>
<h6>last</h6>
<pre class="prettyprint lang-php">
显示/var/log/wtmp文件, 显示用户登陆历史以及系统重启历史
</pre>
<h6>lastb</h6>
<pre>
显示用户错误的登录尝试
</pre>
<h6>lastlog</h6>
<pre>
lastlog: 显示每一个用户最近一次的成功登录信息；
-u USERNAME: 显示特定用户最近的登录信息
</pre>
</section>
<section class="cmd-description grid-item">
<h4>
    <a name="basename" href="#basename">basename</a>
</h4>
<pre class="prettyprint lang-php">
    basename
        $0 执行脚本时的脚本路径及名称
    获取脚本名称
</pre>
</section>
<section class="cmd-description grid-item">
<h4>
    <a name="hostname" href="#hostname">hostname</a>
</h4>
<pre class="prettyprint lang-php">
    主机名
    hostname  实时
    $HOSTNAME 非实时

    hostname newname  修改主机名

</pre>
</section>
<section class="cmd-description grid-item">
<h4>
    <a name="RANDOM" href="#RANDOM">RANDOM</a>
</h4>
<pre class="prettyprint lang-php">
生成随机数 RANDOM: 0-32768
随机数生成器：
/dev/random:
/dev/urandom:
</pre>
</section>
<section class="cmd-description grid-item">
<h4>
    <a name="MBR" href="#MBR">MBR</a>
</h4>
<h6></h6>
<pre class="prettyprint lang-php">
Master Boot Record主引导记录
共512Byte
    446Byte BootLoader  程序
    64Byte 每16Byte标识一个主分区, 每块硬盘只能有4个分区
    2Byte  Magic Number 标记MBR是否有效
</pre>
</section>

<section class="cmd-description grid-item">
    <h4>
        <a name="ln" href="#ln">ln</a>
    </h4>
<pre class="prettyprint lang-php">
ln link 链接

ln [-s -v] SRC DEST

硬链接：
1、只能对文件创建，不能应用于目录；
2、不能跨文件系统；
3、创建硬链接会增加文件被链接的次数；

符号链接：
1、可应用于目录；
2、可以跨文件系统；
3、不会增加被链接文件的链接次数；
4、其大小为指定的路径所包含的字符个数；

ln hardlink dsthardlink
ln -s softlink dstsoftlink

ls -il 用inode去观察软硬链接
硬链接, inode值相同
软链接, 只是路径指向, 文件大小为路径字符串大小
</pre>
</section>
<section class="cmd-description grid-item">
<h4>
    <a name="磁盘管理" href="#磁盘管理">*磁盘管理</a>
</h4>
<h6>du</h6>
<pre class="prettyprint lang-php">
递归统计目录大小
Summarize disk usage of the set of FILEs, recursively for directories.
-s
-h

du -h /etc 统计etc目录下每个文件的大小
du -sh /etc 统计/etc目录的大小

du -ah /etc 统计结果显示不仅需要显示目录, 也得包含文件的大小
</pre>
<h6>df</h6>
<pre>
df - report file system disk space usage
显示磁盘分区情况
-i inode 使用情况
-h 单位换算
-P 美化结果显示, 过长的结果不让换行

df 查看磁盘块使用情况, df -h 转换块单位为人类可识别单位(M,G)
df -i 查看磁盘inodes使用情况

vagrant@homestead:/etc$ df -P -i
Filesystem                    Inodes  IUsed   IFree IUse% Mounted on
udev                          252276    423  251853    1% /dev
</pre>
<h6>设备文件</h6>
<pre>
b: 按块为单位，随机访问的设备；
c：按字符为单位，线性设备；

注意, 设备文件中, 逗号前面的是主设备号, 后面的是次设备号
主设备号（major number）:标识设备类型
次设备号（minor number）:表示同一种类型中不同设备
vagrant@homestead:/etc$ ll /dev/ | grep sd
brw-rw----  1 root    disk      8,   0 Dec 10 14:22 sda
brw-rw----  1 root    disk      8,   1 Dec 10 14:22 sda1
brw-rw----  1 root    disk      8,   2 Dec 10 14:22 sda2
brw-rw----  1 root    disk      8,   5 Dec 10 14:22 sda5

b 表示块设备

硬盘设备的设备文件名：
IDE, ATA：hd
SATA：sd
SCSI: sd
USB: sd
    a,b,c,...来区别同一种类型下的不同设备

IDE:
	第一个IDE口：主、从
		/dev/hda, /dev/hdb
	第二个IDE口：主、从
        /dev/hdc, /dev/hdd

固定的hd硬盘
hda:
	hda1: 第一个主分区
	hda2:
	hda3:
	hda4:
    hda5: 第一个逻辑分区

sd是无序的, 看接口, 看系统内核识别顺序

</pre>
<h6>mknod</h6>
<pre>
创建块或字符设备
mknod [OPTION]... NAME TYPE [MAJOR MINOR]
    -m MODE 权限

// 创建一个字符设备mydev, 主设备号66, 次设备号0
mknod mydev c 66 0
mknod -m 640 mydev2 66 1

// 查看当前tty链接
tty
echo "hello world" >> /dev/pts/0
// 报废一个系统?刺激
echo "hello world" >> /dev/sda

</pre>
</section>
<section class="cmd-description grid-item">
    <h4>
        <a name="fdisk" href="#fdisk">fdisk</a>
    </h4>
<pre class="prettyprint lang-php">
查看当前系统识别了几块硬盘：
fdisk -l [/dev/to/some_device_file]


fdisk /dev/sda
	p: 显示当前硬件的分区，包括没保存的改动
	n: 创建新分区
		e: 扩展分区
		p: 主分区
	d: 删除一个分区
	w: 保存退出
	q: 不保存退出
	t: 修改分区类型
		L:
    l: 显示所支持的所有类型

当前系统内核分区信息, fdisk分区后, 内核还没有加载

partprobe 重读内核分区表红帽5以前, 一般用这个
partx 6
cat /proc/partitions
</pre>
<h6>分区操作</h6>
<pre>
// 1. 查看自身分区情况
fdisk -l
Device     Boot   Start      End  Sectors  Size Id Type
/dev/sda1  *       2048   999423   997376  487M 83 Linux
/dev/sda2       1001470 83884031 82882562 39.5G  5 Extended
/dev/sda5       1001472 83884031 82882560 39.5G 8e Linux LVM
// 2. 操作分区
fdisk /dev/sda
// 3. 进入了命令行模式
p #打印显示当前分区情况
Disk /dev/sda: 40 GiB, 42949672960 bytes, 83886080 sectors
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disklabel type: dos
Disk identifier: 0x1d4bba8c

Device     Boot   Start      End  Sectors  Size Id Type
/dev/sda1  *       2048   999423   997376  487M 83 Linux
/dev/sda2       1001470 83884031 82882562 39.5G  5 Extended
/dev/sda5       1001472 83884031 82882560 39.5G 8e Linux LVM

// 其中id为分区类型, 输入l, 列出id 和分区类型的对应关系
...
82 Linux swap / So
83 Linux
...

// 新建分区
n
|--p 主分区(最多4个,第四个一般设置为扩展, 可以继续设置分区)
|--e 扩展分区

p 创建一个主分区
|--Partition number 选择分区编号(一般为1-4), 默认可以直接按回车
   |--First sector 开始扇区编号
   |--Last sector 结束扇区编号   输入可以"+10G",表示分区大小

w 保存退出
q 退出,放弃操作

// 4.更新分区
cat /proc/partitions
// RH5通知内核更新分区
partprobe
partprobe /dev/sda
// RH6通知内核更新分区
partx -u /dev/sda

</pre>
<h6>mkfs</h6>
<pre>
make file system

// 查看当前内核所支持的文件系统类型, 然后确定-t选项, 不支持的文件系统类型是因为内核不支持, 内核编译的时候去掉了
// vfat == fat32
cat /proc/filesystem

// 格式化分区文件系统, 重新创建文件系统会损坏原有文件,  这个命令也是意味格式化
mkfs -t ext2 /dev/sda5
等同于
mkfs.ext3 /dev/sdb5


创建成功后观察提示信息
...
Block size=4096 (log=2)
...
655360 inodes, 2621440 blocks
...
131072 blocks (5.00%) reserved for the super user
...
80 block groups
32768 blocks per group...
8192 inodes per group
Superblock backups stored on blocks:
    32768, 98304, 163840, 229376,...
...
Creating journal (32768 blocks): done
...

32768 blocks / 8192 inodes = 4, 每4个block一个inode, 16K

inode: 记录与自身相关的block磁盘信息,快速定位, 属组,属主,inode编号,时间戳, 文件大小

Filesystem label 文件系统的卷标(C,D)

block groups 块组

journal: ext3 后的日志功能,数据写入inode信息,先保存在log块, 然后在转移, 以达到修复硬盘快速定位错误数据

预留5%的空间给予系统管理员在将来磁盘空间出问题的时候维护

Superblock 拥有多个备份, 记录全局信息,如多少块组, 每个块组大小, 块大小, Inode空闲信息等

超级块组的信息显得至关重要, 因而备份是十分必要, 每一个块组都有自己的块位图,inode块图

// 磁盘被划分了N个块组组成
BootBlock - block group 0 -Block group 1 ....
// 一个块组组成
Superblock-GDT(group descript 快组描述)-Block Bitmap-Inode Bitmap-Inode Table-Data Block

// sdb6使用fat32文件系统,
mkfs.vfat /dev/sdb6
</pre>

<h6>mke2fs(同样适用与mkfs系列)</h6>
<pre>
选项
-j 创建ext3文件系统
-b 指定Block Size大小, 默认4096, 这个参数基本不用动, 提升了系统提示太大
    mke2fs -b 2048 /dev/sdb5
-L volume-label 卷标, File System Label
    mke2fs -L WEB_DATA /dev/sdb5
-m 预留给超级用户的块百分比,默认为5个百分比, 进输入数字即可, 这个命令还是很有意义的, 尤其大硬盘
     mke2fs -m 3 /dev/sdb5
-i 指定多少个字节大小就产生一个inode, 块的倍数
     mke2fs -i 4096 /dev/sdb5
-N 手动指定inode个数,不按照块字节比例创建了
-F 强制
-E 用户指定额外文件系统属性

提示内容和mkfs.ext系列相同,不再详述

mk ->tab查看mk相关命令

// ext2文件系统, 等同mkfs.ext2 /dev/sdb5
mke2fs /dev/sdb5
// ext3
// 多一行提示Creating journal (32768 blocks): done
mke2fs -j /dev/sdb5

// 为分区sdb6, 创建一个ext4文件系统预留3%空间给系统管理员维护硬盘,卷标为TEST_DATA
mkfs.ext4 -m 3 -L TEST_DATA /dev/sdb6

</pre>

<h6>blkid</h6>
<pre>
查看block属性, 磁盘属性

[root@localhost centos]# blkid /dev/sdb6
/dev/sdb6: LABEL="TEST_DATA" UUID="24713fc9-9d74-4aca-aac6-62cce331cf3b" TYPE="ext4"
[root@localhost centos]#
</pre>
<h6>e2label</h6>
<pre>
// 查看卷标
e2label /dev/sdb5
// 设置卷标
e2label /dev/sdb5 WEB_DATA
</pre>
<h6>findfs</h6>
<pre>
findfs [options] {LABEL,UUID,PARTUUID,PARTLABEL}=value
findfs LABEL=WEB_DATA
</pre>
<h6>tune2fs</h6>
<pre>
查看超级块信息
无损升级 ext2->ext3等属性转换, 文件不损坏, 有数据也没问题,其他文件系统不可以
-j 设置ext3格式
-L 设置卷标
-m 调整预留百分比
-r 预留块数量,而不是百分比
-o 设定默认规则
   acl 文件访问控制
-c Maximum mount count 指定挂在次数达到设定值后进行自检, 0或-1关闭此功能
-i Mount count 没挂载多少天后进行自检,0或-1关闭此功能, 结合-c使用
-l 显示超级块中的信息, 很有用的选项

// 为分区/dev/sdb5创建一个ext2文件系统
[root@localhost centos]# mke2fs -L WEB_DATA /dev/sdb5
// 无损变更为ext3
[root@localhost centos]# tune2fs -j /dev/sdb5
tune2fs 1.42.9 (28-Dec-2013)
Creating journal inode: done
// 查看结果
[root@localhost centos]# blkid /dev/sdb5
/dev/sdb5: LABEL="WEB_DATA" UUID="4ddb3cab-1cd8-4ea4-ac23-37a57636893d" SEC_TYPE="ext2" TYPE="ext3"

// 卷标
tune2fs -L WWW /dev/sdb

tune2fs -m 1 /dev/sdb5
</pre>
<h6>dumpe2fs</h6>
<pre>
显示超级块中的信息
dumpe2fs /dev/sdb5
dumpe2fs -h /dev/sdb5 只显示超级块信息

详细的dumpe2fs 包含了每个分组的信息, 从信息的free block中可以清晰地看到文件碎片的表现形式, 不连续的block空间
</pre>

<h6>fsck</h6>
<pre>
检查并且修复文件系统
-t FSTYPE: 指定文件系统类型, ext4
-a 自动修复
</pre>

<h6>e2fsck</h6>
<pre>
修复ext2,ext3文件系统了些
-f 强制
-p 自动修复

e2fsck -f /dev/sdb5
e2fsck -f -p /dev/sdb5

</pre>

<h6>mount</h6>
<pre>
-a 挂载/etc/fstab中的所有文件系统
-n 默认情况下, 挂载一个设备都保存信息在/etc/mtab, -n选项表示挂载时不写入这个文件
-t FSTYPE, 指定正在挂载的文件系统类型,默认可以不指定, 程序调用blkid自动获取
-r 只读挂载,光盘常用
-w 读写挂载
-o 指定额外的挂载选项, 详情看man, 默认异步(async),actime等
    ro
    rw
    remount
    mount -o remount,ro,noexec,loop /dev/sdb5 /mnt/test
--bind
--move

挂载文件系统
mkdir /mnt/test
mount /dev/sdb5 /mnt/test

mount 不带参数显示当前已经挂载的设备, 和挂载点(实际上显示/etc/mtab文件信息)

挂载iso
mount -o loop /home/test.iso /media
</pre>

<h6>umount</h6>
<pre>
1. 设备不在占用
2. 事先存在
3. 目录中的原有文件暂时隐藏

mount /dev/sdb5
或者
mount /mnt/test
</pre>
</section>
<section class="cmd-description grid-item">
<h4>
    <a name="free" href="#free">free</a>
</h4>
<h6></h6>
<pre class="prettyprint lang-php">
查看内存使用情况

free -m
              total        used        free      shared  buff/cache   available
Mem:           2000         297        1019          70         683        1426
-/+ buffers/cache:          201        300
Swap:          1023           0        1023

真正使用空间为-200, 自由空间为+300, 因为buff.cache是可以释放的

</pre>
</section>
<section class="cmd-description grid-item">
<h4>
    <a name="dd" href="#dd">dd</a>
</h4>
<h6></h6>
<pre class="prettyprint lang-php">
if in file
of out file
dd if=/dev/zero of=/swapfile bs=1M count=1
</pre>
</section>
<section class="cmd-description grid-item">
<h4>
    <a name="fuser" href="#fuser">fuser</a>
</h4>
<h6></h6>
<pre class="prettyprint lang-php">
fuser: 验正进程正在使用的文件或套接字文件
	-v: 查看某文件上正在运行的进程
    -km: 终止访问某文件挂载点的所有进程

fuser -v /home 查看home目录下的所有进程

fuser -km /mnt/cdrom 结束/mnt/cdrom的所有程序
</pre>
</section>
                </div>
            </div>
        </div>
    </div>
</div>
</div>
<script src="assets/js2/jquery.js"></script>
<script src="assets/js2/jquery.highlight-4.js"></script>
<script src="assets/js2/google-code-prettify/prettify.js"></script>
<script src="assets/js2/foundation.min.js"></script>
<script src="assets/js2/masonry.js"></script>
<script src="assets/js2/app.js"></script>

<script>
    (function (i, s, o, g, r, a, m) {
        i['GoogleAnalyticsObject'] = r;
        i[r] = i[r] || function () {
                (i[r].q = i[r].q || []).push(arguments)
            }, i[r].l = 1 * new Date();
        a = s.createElement(o),
            m = s.getElementsByTagName(o)[0];
        a.async = 1;
        a.src = g;
        m.parentNode.insertBefore(a, m)
    })(window, document, 'script', '//www.google-analytics.com/analytics.js', 'ga');

    ga('create', 'gaTrackingID', 'auto');
    ga('send', 'pageview');

</script>
</body>
</html>
