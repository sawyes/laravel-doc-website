<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <link rel="shortcut icon" href="assets/ico/favicon.png">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="author" content="@summer">
    <title>Linux 常用命令</title>
    <meta name="description" content="Laravel 5.1 LTS 速查表方便快速浏览，支持并且只支持 Laravel 5.1 LTS，支持手机访问，支持中英文版本">
    <meta name="keywords" content="linux 学习笔记">
    <link rel="stylesheet" href="assets/css2/normalize.css" />
    <link rel="stylesheet" href="assets/css2/foundation.min.css" />
    <link rel="stylesheet" href="assets/css2/font-awesome.min.css" />
    <link rel="stylesheet" href="assets/css2/page.css" />
    <style>
        .code-column h6 {
          color: #3adb76;
        }
    </style>
</head>
<body>

<div class="off-canvas-wrapper wrapper-container">
    <div class="off-canvas-wrapper-inner" data-off-canvas-wrapper>

        <div class="off-canvas position-left sidebar-canvas" id="offCanvasLeft" data-off-canvas data-position="left">
            <button class="close-button" aria-label="Close menu" type="button" data-close>
                <span aria-hidden="true">&times;</span>
            </button>
            <ul class="mobile-ofc vertical menu">
                <li>
                    <button class="warning hollow button check-all-button">查看全部</button>
                </li>
                <li>
                    <ul class="submenu menu vertical mobile-cmd-cell" data-submenu>
                    </ul>
                </li>
            </ul>
        </div>

        <div class="off-canvas-content" data-off-canvas-content>
            <div class="title-bar hide-for-medium">
                <div class="title-bar-left">
                    <button class="menu-icon" type="button" data-open="offCanvasLeft"></button>
                </div>
            </div>
        </div>

        <a href="#top" id="top-button" title="Top"><i class="icon-arrow-up"></i></a>
        <a href="#" class="comments-toggle" title="隐藏/展示代码注释"><i class="icon-eye-close"></i></a>

        <div class="row full-width">

            <div class="large-2 columns code-column sidebar">
                <h5 class="sidebar-title">Linux 常用命令</h5>
                <hr class="horizonal-line">
                <div class="show-for-medium">
                    <button class="warning hollow button check-all-button">查看全部</button>

                    <div class="clearfix"></div>
                    <ul class="sidebar-menu">
                    </ul>

                    <div class="clearfix"></div>

                    <hr class="horizonal-line">
                </div>
                <ul class="sidebar-bottom">
                    <li><a href="https://www.kernel.org/" class="button expand small radius alert">Linux Kernel</a></li>
                </ul>
            </div>
            <div class="large-10 columns code-column code-container">
                <div class="grid">
<!--                    
<section class="cmd-description grid-item">
<h4><a name="模板" href="#模板">模板</a>
<a target='_blank' href="" title="模板"><i class="icon-file-text"></i></a></h4>

<pre class="prettyprint lang-shell">

</pre>

<h6>模板2 <a target='_blank' href="" title="模板2"><i class="icon-file-text"></i></a></h6>
<pre class="prettyprint lang-shell">
</pre>
</section>
-->
<section class="cmd-description grid-item">
<h4><a name="目录管理" href="#目录管理">目录管理</a>
<h6>查看ls</h6>
<pre class="prettyprint lang-php">
蓝色表示目录；
绿色表示可执行文件；
红色表示压缩文件；
浅蓝色表示链接文件；
白色表示其他文件；
黄色是设备文件，包括block, char, fifo。

-：普通文件 (f)
d: 目录文件
b: 块设备文件 (block)
c: 字符设备文件 (character)
l: 符号链接文件(symbolic link file)
p: 命令管道文件(pipe)
s: 套接字文件(socket)

//list命令
ls -al
// drwxrwxr-x 993 vagrant vagrant 36864 Aug 16 17:03 .npm

type ls
//ls is aliased to `ls --color=auto'
type ll
//ll is aliased to `ls -l --color=auto'
// 用人类能理解的方式输出大小 -h 好多命令都有， 注意大小变为36K
ls -alh
// drwxrwxr-x 993 vagrant vagrant  36K Aug 16 17:03 .npm
</pre>
<h6>mkdir</h6>
<pre>
-p parent
-v 详细过程
// 命令行展开
mkdir -pv /mnt/test/{x/m,y}
</pre>

<h6>tree</h6>
<pre class="prettyprint lang-php">
// 可能需要自行安装
// ubuntu
sudo apt-get install tree
// centos
rpm -qa tree
mkdir /mnt/cdrom
mount /dev/cdrom /mnt/cdrom
rpm -ivh tree-1.5.3-2.el6.i686.rpm
//查看目录结构
tree test
test
├── ac
├── ad
├── bc
└── bd
</pre>

</section>

<section class="cmd-description grid-item">
    <h4><a name="文件管理" href="#文件管理">文件管理</a></h4>

<h6>cp复制</h6>
<pre class="prettyprint lang-php">
cp SRC DEST
-r 递归
-i 覆盖是询问
-f 强制
-a(archive 啊k爱)：归档复制，常用于备份
-L always follow symbolic links in SOURCE
-P never follow symbolic links in SOURCE

// 归档备份, 属性，软连接等全部保留
cp -a /etc /backup/etc-2013-02-28

// 复制文件夹下的内容到另一个文件夹下, 如初始化用户
cp -r /etc/skel/. /home/user1
</pre>
<h6>touch创建文件</h6>
<pre class="prettyprint lang-php">
// 变更文件的变更时间
touch -mt 201701011248 filename
// 其他参数
-a access time
-t time string 
-m modify time
-c change time
</pre>
<h6>rm删除文件</h6>
<pre class="prettyprint lang-php">
// redhat中默认是别名，只有root用户是这样
type rm
//rm is aliased to `rm -i'， -i 交互式
// 忽略别名运行命令本身
\rm -fr 1.txt
// 删除文件：rm
  -i  交互
  -f  不用咨询，强制删除
  -r -R 都是递归
rm -fr 1.txt
</pre>
    <h6>stat</h6>
<pre class="prettyprint lang-php">
stat filename 
  File: "filename"
  Size: 1965        Blocks: 8          IO Block: 4096   普通文件
Device: fd00h/64768d    Inode: 654681      Links: 1
Access: (0755/-rwxr-xr-x)  Uid: (    0/    root)   Gid: (    0/    root)
Access: 2017-10-27 00:15:26.236270025 +0800
Modify: 2017-10-27 00:15:26.236270025 +0800
Change: 2017-10-27 00:15:26.236270025 +0800
</pre>
</section>

<section class="cmd-description grid-item">
    <h4><a name="环境变量" href="#环境变量">环境变量</a></h4>
    <pre class="prettyprint lang-shell">
// 输出环境变量
printenv
// 更新环境变量, 可以解决man 乱码问题
export LANG=en
// 基于printenv的键，可以直接用变量的方式输出
$PATH
$HISTSIZE
$SHELL 当前用户shell

// 环境变量添加路径
# PATH=$PATH:/tmp

// 输出当前用户环境变量，echo $PATH,如何做到添加变量，添加用户的时候拥有默认环境变量
    </pre>
<h6>hash o(1)<a target='_blank' href="http://blog.csdn.net/wendavidoi/article/details/50670016" title="Artisan CLI @ Laravel Docs"><i class="icon-file-text"></i></a></h6>
<pre>
// 查看命令的命中率
    hash
</pre>
</section>

<section class="cmd-description grid-item">
<h4><a name="快捷键" href="#快捷键">快捷键</a></h4>
<h6>文本查找</h6>
<pre class="prettyprint lang-php">
//man,vim中
/KEYWORD: 向后
n: 下一个
N：前一个 
?KEYWORD：向前
n: 下一个
N：前一个

</pre>
<h6>X window中翻屏(黑窗口)</h6>
<pre>
shift + pageup
shift + pagedown
</pre>
</section>

<section class="cmd-description grid-item">
    <h4><a name="date" href="#date">date</a></h4>
    <h6>date 系统时间管理</h6>
<pre class="prettyprint lang-php">
// RTC real time clock 实时时钟
// UTC 时间
 date -u +'%F %T'
// 日期转成时间戳 输出 1508867210
date -d '2017-10-25 01:46:50' +%s
// 时间戳转换为日期
date --date='@1508867210' +'%F %T'
// +8小时
date --date='now +8 hours' +'%F %T'

// 时区+时间戳
TZ='Asia/Shanghai' date --date='@1508867210' +'%F %T' => 上海日期2017-10-25 01:46:50
TZ='Asia/Shanghai' date --date='2017-10-25 01:46:50' +'%s' => 时间戳1508867210
// **给定上海日期字符串，求当时的UTC时间
date --date='TZ="Asia/Shanghai" 2017-11-29 02:22:00' +'%F %T' => 2017-11-28 18:22:00

// 手动设置系统时间
date -s '2017-10-25 01:46:50'

// 查看时区
/usr/share/zoneinfo/
命令tzselect  (man date中有提及tzselect)

// 变更系统时区
man hwclock中有提及,添加TZ变量可以覆盖系统设置的时区
$ TZ=Asia/Shanghai
$ export TZ
$ PATH=$PATH:$TZ

</pre>
    <h6>hwclock 时间校准</h6>
<p>硬件时钟 clock  由电池纽扣控制</p>
<p>系统时钟 date   由系统控制， 但是CPU可能繁忙导致时间出错</p>
<pre class="prettyprint lang-php">
hwclock -w
// Set the System Time from the Hardware Clock
hwclock -s
// Set the Hardware Clock to the current System Time
</pre>
    <h6>cal日历</h6>
<pre class="prettyprint lang-php">
cal
cal 2012
cal 02 2012
</pre>
</section>

<section class="cmd-description grid-item">
    <h4><a name="alias" href="#alias">alias</a></h4>

<pre class="prettyprint lang-php">
永久生效 vim ~/.bashrc
// alias 是bash命令，只在bash生命周期内有效
// 临时别名，存储当前会话
alias etc='cd /etc'
// 永久写入文件
vim ~/.bashrc
// 立刻生效
source ~/.bash
// 查看所有命令
alias

// 为什么source后才能生效？ 因为alias在登录的时候已经加载到内存，此时是无法知道配置修改
</pre>
</section>

<section class="cmd-description grid-item">
    <h4><a name="文本处理" href="#文本处理">文本处理</a></h4>
    <h6>printf</h6>
<pre class="prettyprint lang-php">
printf "hello, %s\r\n" world
//hello, world
printf "float %.2f\r\n" 1.11911
//float 1.12
</pre>
<h6>tr</h6>
<pre>
// 默认为交互式，同时出现 ab转换AB
tr 'ab' 'AB'
// 结合重定向, 逐个字符比较，替换为大写
tr 'a-z' 'A-Z' < /etc/passwd
// 出现字符a或者b都会删除
tr -d 'ab'
</pre>
</section>

<section class="cmd-description grid-item">
    <h4><a name="查看文本" href="#查看文本">查看文本</a></h4>
<h6>cat、tac、more、less、head、tail</h6>
    <h6>cat || tac</h6>
<pre class="prettyprint lang-php">
-n 行号
-E 显示结束符
-a 显示特殊符号

// 可以连接多个文件
cat 1.txt 2.txt

// 和egrep结合，过滤空行和#开头的字符
// 理解^$为什么是空行？因为linux空行就是只有一个$结束符号，用-E命令可以理解
cat httpd.conf | egrep -v '^$|#'
</pre>
<h6>more 翻屏</h6>
<pre>
backspace 向后一页
b 向前一页
</pre>
<h6>less 用得最多</h6>
<pre>
// 支持搜索，翻到最后不退出， man命令就是less打开的
backspace 向后一页
b 向前一页
</pre>
<h6>tail | head</h6>
<pre>
-n 显示多少行  
tail -f: 查看文件尾部，不退出，等待显示后续追加至此文件的新内容；  

第9行数据
head -9 /etc/inittab | tail -1

倒数第9行
tail -9 /etc/inittab | head -1

</pre>
<h6>cut</h6>
<pre>
-d delimiter 分隔符,默认为空格
-f field 制定要显示字段
// 冒号作为分隔符，截取第一个字段
cut -d : -f 1 /etc/passwd
// -f1,3  显示1,3字段
// -f1-3  显示1到3个字段
</pre>
<h6>sort</h6>
<pre>
// 默认ascii字符排序
-r 逆序
-n 按数值大小排序  
-t, --field-separator=SEP字段分隔符
-k key=pos1,pos2第几个位置作为排序依据
-u uniq 去重
-f 排序忽略字符大小写
// :分割passwd , 以第三个字段逆序输出
sort -t: -k3 -r /etc/passwd
// 按照文件大小排序
ll -h| sort -nk5
</pre>
<h6>uniq</h6>
<pre>
//相邻重复的行才认为是重复的行
-c 重复的次数
-d 只显示重复的行，去重后的值
-D  显示重复的行的所有内容
</pre>
<h6>wc</h6>
<pre>
// word count, 默认显示格式
行 单词数 字节数    
-c, --bytes 输出字节数统计
-m, --chars 输出字符数统计
-l, --lines 输出行数统计
</pre>
</section>
<section class="cmd-description grid-item">
    <h4><a name="查看版本" href="#查看版本">查看版本</a></h4>
    <h6></h6>
<pre class="prettyprint lang-php">
lsb_release
cat /etc/lsb-release
cat /etc/issue
cat /proc/version
uname -a
</pre>
</section>
<section class="cmd-description grid-item">
    <h4><a name="bash" href="#bash">bash</a></h4>
<h6>光标跳转：</h6>
<pre>
Ctrl+a：跳到命令行首
Ctrl+e：跳到命令行尾
Ctrl+u: 删除光标至命令行首的内容
Ctrl+k: 删除光标至命令行尾的内容
Ctrl+l: 清屏
Ctrl+d: 向后删除一个字符
</pre>
<h6>命令历史：</h6>
<pre>
查看命令历史：history
-c：清空命令历史
-d OFFSET [n]: 删除指定位置的命令
-w：保存命令历史至历史文件中

// 执行history中制定行号的命令,感叹号
!890
// 执行倒数第四条命令
!-4
// 执行上一条命令
!!
// !+ 字符串，执行命令历史中最近一个指定字符串开头的命令
!ls
// 引用前一个命令的最后一个参数
cat /etc/httpd/conf/http.conf
vim !$
// 获取钱一个命令的最后一个参数到终端
按 ESC 然后按 .
cat /etc/httpd/conf/httpd.conf
vim 按 ESC 然后按 
</pre>
<h6>shell的类型</h6>
<pre>
登录式shell:
    正常通常某终端登录
    su - USERNAME 
    su -l USERNAME
/etc/profile --> /etc/profile.d/*.sh --> ~/.bash_profile --> ~/.bashrc --> /etc/bashrc(全局shell)

非登录式shell:
    su USERNAME  （半切换）
    图形终端下打开命令窗口
    自动执行的shell脚本
~/.bashrc --> /etc/basrc --> /etc/profile.d/*.sh
没读取/etc/profile，~/.bash_profile
</pre>
<h6>bash的配置文件</h6>
<pre>
// 默认创建的用户shell都是来自于/etc/skel配置
// .bash_logout   .bashrc  .gnome2
// .bash_profile  .emacs   .mozilla

全局配置
    /etc/profile, /etc/profile.d/*.sh(所有文件), /etc/bashrc
个人配置
    ~/.bash_profile, ~/.bashrc

profile类的文件：设定环境变量，登录前运行命令或脚本，全局和个人都有的时候以个人为准

bashrc类的文件：设定本地变量，定义命令别名(alias)

// 编写profile，登录的时候执行脚本输出hello world
vim ~/.bash_profile
    echo "hello world!"
</pre>
</section>
<section class="cmd-description grid-item">
    <h4><a name="命令替换" href="#命令替换">命令替换</a></h4>
<pre>
bash支持的引号：
``: 命令替换
"": 弱引用，可以实现变量替换
'': 强引用，不完成变量替换
</pre>
<H6>$(COMMAND)</H6>
<pre class="prettyprint lang-php">
echo "current path is $(pwd)"
// current path is /etc/httpd/conf
touch ./file-$(date +%F).txt
</pre>
<h6>反引号命令替换`COMMAND`</h6>
echo "current path is `pwd`"
</section>
<section class="cmd-description grid-item">
    <h4><a name="通配符" href="#通配符">通配符</a></h4>
    <h6>man 7 glob</h6>
<pre class="prettyprint lang-php">
*: 任意长度的任意字符
?：任意单个字符
[]：匹配指定范围内的任意单个字符
[abc], [a-m], [a-z], [A-Z], [0-9], [a-zA-Z], [0-9a-zA-Z]
[:space:]：空白字符
[:punct:]：标点符号
[:lower:]：小写字母
[:upper:]: 大写字母
[:alpha:]: 大小写字母
[:digit:]: 数字
[:alnum:]: 数字和大小写字母
    
# man 7 glob
[^]: 匹配指定范围之外的任意单个字符
// 字母开头中间有空格非字母结尾
ls [[:alpha:]]*[[:space:]]*[^[:alpha:]]
</pre>
</section>

<section class="cmd-description grid-item">
<h4><a name="管道" href="#管道">管道</a></h4>
<pre>
把前一个命令的输出当做后一个命令的输入
命令1 | 命令2 | 命令3

// 输出内容全部大写
echo "hello world" | tr "a-z" "A-Z"

// 标准输入修改密码
echo "passwd" | passwd --stdin user1

// 统计用户数
wc -l /etc/passwd | cut -d' ' -f1
</pre>
<h6>tee</h6>
<pre>
既能输出到屏幕，也能保存到文件
echo "hello world" > tee hello.txt

// 取出密码文件倒数第9行的用户名和shell路径保存文件并输出
tail -9 /etc/passwd | head -1|cut -d: -f1,7| tee /tmp/user.out
</pre>
</section>

<section class="cmd-description grid-item">
<h4><a name="grep" href="#grep">grep</a></h4>
<h6>内容查找</h6>
<pre class="prettyprint lang-php">
grep: 
-i 不区分大小写
-r -R 递归
-n 显示行号
-E 等同于egrep, 扩展正则表达式
-F 等同于fgrep, 不支持正则表达式，因而速度非常快
--color 添加颜色
-v 过滤（反向查找），显示没有被模式匹配到的行
-o 紧显示被匹配到的字符串，不会显示行
-A 匹配内容后的行数也显示

正则
*
?
[]
[^]

匹配次数（默认贪婪模式）
. : 匹配任意单个字符
* ：表示匹配前面一个字符出现任意次，甚至是0次
.* : 表示任意字符,任意次数,包括空格
? : 匹配前一个字符一次或0次
\{m,n\} : 匹配前一个字符次数范围
^ : 以字符开头
$ ：以字符结束
^$ : 空白字符
\(\) : 分组，捕获
记忆法\<content\>
\<: \<content 以content开头的单词
\>: content\> 以content结尾的单词

贪婪模式，匹配结果尽可能的长
非贪婪模式，匹配结果尽可能的短

// 有分号和没分号的区别
实例文件匹配 httpd.conf
// 贪婪模式
ls | grep htt*  > 输出文件httpd.conf， 匹配httpd.conf
// 非贪婪模式
ls | grep 'htt*' > 输出文件httpd.conf， 匹配httpd

// 默认是贪婪模式
grep h.*p httpd.conf
等同于
grep 'h.*p' httpd.conf
类似于（不能匹配标点[[:punct:]]  man 7 glob）
grep 'ht[[:alnum:]]*p' httpd.conf
// 匹配1或0个t
grep 'htt\?p' httpd.conf
// 匹配至少1个t
grep 'htt\{1,\}pd' httpd.conf
// 找出以ly结尾的单词
cat httpd.conf | grep 'ly\>'
// 找出以ly开始的单词
cat httpd.conf | grep '\bly'
// 捕获
cat httpd.conf | grep '\(h.*p\).*\1d'


// grep 颜色
vim ~/.bashrc
alias grep='grep --color'
// 文件内容查找
grep root /etc/passwd
// 忽略大小写递归查找文本内容vhost*, 显示匹配的文件，以及内容所在行号
grep -rin vhost* .
// 匹配内容，并且加上后面两行
grep -A 2 '^cache' /proc/cpuinfo
// 前两行
grep -B 2 '^cache' /proc/cpuinfo
// 前后两行
grep -C 2 '^cache' /proc/cpuinfo 

// 匹配ip地址
alias ipaddr="egrep --color '(\<([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\>\.){3}\<([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\>'"
ifconfig | ipaddr



练习：
1、显示/proc/meminfo文件中以不区分大小的s开头的行；
grep -i '^s' /proc/meminfo
grep '^[sS]' /proc/meminfo
2、显示/etc/passwd中以nologin结尾的行; 
grep 'nologin$' /etc/passwd

取出默认shell为/sbin/nologin的用户列表
grep "nologin$' /etc/passwd | cut -d: -f1

取出默认shell为bash，且其用户ID号最小的用户的用户名
grep 'bash$' /etc/passwd | sort -n -t: -k3 | head -1 | cut -d: -f1

3、显示/etc/inittab中以#开头，且后面跟一个或多个空白字符，而后又跟了任意非空白字符的行；
grep "^#[[:space:]]\{1,\}[^[:space:]]" /etc/inittab

4、显示/etc/inittab中包含了:一个数字:(即两个冒号中间一个数字)的行；
grep ':[0-9]:' /etc/inittab

5、显示/boot/grub/grub.conf文件中以一个或多个空白字符开头的行；
grep '^[[:space:]]\{1,\}' /boot/grub/grub.conf

6、显示/etc/inittab文件中以一个数字开头并以一个与开头数字相同的数字结尾的行；
grep '^\([0-9]\).*\1$' /etc/inittab
</pre>
<h6>忽略空行和注释</h6>
<pre>
// 空行的真谛，默认地linux结尾为$
 cat -E httpd.conf
 因而^$就表示空行了

egrep -v "#|^&" /etc/httpd/conf/http.conf
cat /etc/httpd/conf/http.conf | egrep -v "#|^$"
cat /etc/httpd/conf/http.conf | grep -vEn "#|^$"
</pre>
</section>

<section class="cmd-description grid-item">
    <h4><a name="find" href="#find">find</a></h4>
<h6>基础</h6>
<pre class="prettyprint lang-php">
find path -name "regexp"
find 查找路径 查找标准 查找到以后的处理运作
查找路径：默认为当前目录
查找标准：默认为指定路径下的所有文件
处理运作：默认为显示
</pre>

<h4>时间范围</h4>
<pre>
-mtime n file's data was last modified n*24 hours ago
-ctime n file's  status  was  last  changed  n*24 hours ago.
-atime
    [+|-]#
-mmin
-cmin
-amin
    [+|-]#
</pre>
<h4>权限</h4>
<pre>
-executable
-readable
-print
Search for files which are executable but not readable.
find /sbin /usr/sbin -executable \! -readable -print
</pre>
<h4>实例</h4>
<pre>
1、查找/var目录下属主为root并且属组为mail的所有文件；
find /var -user root -group mail

2、查找/usr目录下不属于root,bin,或student的文件；
find /usr -not -user root -a -not -user bin -a -not -user student
find /usr -not \( -user root -o -user bin -o -user student \)

3、查找/etc目录下最近一周内内容修改过且不属于root及student用户的文件；
find /etc -mtime -7 -not \ ( -user root -o -user student \)
find /etc -mtime -7 -not -user root -a -not -user student


4、查找当前系统上没有属主或属组且最近1天内曾被访问过的文件，并将其属主属组均修改为root；
find / \( -nouser -o -nogroup \) -a -atime -1 -exec chown root:root {} \; 

5、查找/etc目录下大于1M的文件，并将其文件名写入/tmp/etc.largefiles文件中；
find /etc -size +1M >> /tmp/etc.largefiles

6、查找/etc目录下所有用户都没有写权限的文件，显示出其详细信息；
find /etc -not -perm /222 -ls	
</pre>


</section>

<section class="cmd-description grid-item">
    <h4><a name="xargs" href="#xargs">xargs</a></h4>
    <h6></h6>
<pre class="prettyprint lang-php">
find / -size +100M | xargs {} > /tmp/large.file
</pre>
</section>

<section class="cmd-description grid-item">
    <h4><a name="locate" href="#locate">locate</a></h4>
    <h6></h6>
<pre class="prettyprint lang-php">
非实时,根据系统数据进行查找

updatedb 更新数据库索引, 默认地最近创建的文件无法查找, 所以必须先得索引

locate -A 搜索所有
locate -b redis 字符匹配 搜索文件名含有redis的文件(不是路径)
locate --regexp 'etc.*redis.*f' 正则匹配
locate -i REDIS 忽略大小写匹配
locate -e redis.conf 仅显示locate数据库中存在,同时文件在系统中也存在的文件
</pre>
</section>

<section class="cmd-description grid-item">
    <h4><a name="权限管理" href="#权限管理">*权限管理</a></h4>
<h6>umask</h6>
<pre>
umask 遮罩码

linux哲学思想，文件默认不能有执行权限

管理员默认遮罩码：022
普通用户： 002
如果文件一旦计算存在执行权限，默认+1

umask 022 我的文件其他人只能读
touch abc.file  666-022 = 644 rw-r--r--（777-022=755=744，有1组成的全部去掉）

umask 023 我的文件其他人只能读
touch qq.file   666-023 = 643+1 rw-r--r--

umask 027 同组才能读
umask 002 其他人只能读，同组权限全款

那么普通用户是怎么确认到这个umask的？即默认的创建文件权限
vim /etc/bashrc 这个时候就看见了umask的设定代码
根据登录shell的bash加载流程图，先加载全局的/etc/bashrc，可以看出了系统的实现
</pre>
<h6>chown</h6>
<pre>
// 属主
chown -R username /path
// 属组
chown -R :groupname /path
// 同时修改
chown -R username:groupname /path
</pre>
<h6>chgrp</h6>
<pre>
chgrp groupname filename
</pre>
<h6>chmod</h6>
<pre>
修改用户权限,3种表达方式

chmod -R 755 /path

chmod u=rwx /path
chmod g=rw /path
chmod o=rx /path
chmod g=r,o=w /path
chmod go=rx /path

chmod u-x,g+x /path

suid 不到最后使用suid
chmod u+s /bin/cat
-rwsr-xr-x 1 root root 52080 Feb 18  2016 cat*
/usr/bin/passwd 是特殊场景
如果文件本身就有执行权限, 那么suid显示为s, 否则S

guid 非常有用的知识点
// 指定目录为guid权限, 则目录内创建的任何文件都为上级的属组
chmod g+ws /home/project/log
chown :logger /home/project/log
// 追加用户到同一个附加组, 此时log文件夹下所有创建的文件都是logger组
usermod -a -G loger hadoop
usermod -a -G loger hive
usermod -a -G loger hbase

// sticky 和guid结合使用,否则创建文件不会有相同的组
// 表示一个公共目录中任何人都可以创建删除自己的文件, 但是不能删除别人的文件
chmod o+t /home/project/log


</pre>
<h6>基础</h6>
<pre class="prettyprint lang-php">
权限：
r, w, x

文件：
r：可读，可以使用类似cat等命令查看文件内容；
w：可写，可以编辑或删除此文件；
x: 可执行，exacutable，可以命令提示符下当作命令提交给内核运行；

目录：
r: 可以对此目录执行ls以列出内部的所有文件；
w: 可以在此目录创建文件；
x: 可以使用cd切换进此目录，也可以使用ls -l查看内部文件的详细信息；

rwx:
r--:只读
r-x:读和执行
---：无权限

u: 属主 owner user
g: 属组 group
o：其他 other
</pre>
<h6>特殊文件</h6>
<pre>
// 理论上任何人都可以查看passwd
用户：UID, /etc/passwd
-rw-r--r-- 1 root root 2109 Apr  6  2017 /etc/passwd
组：GID, /etc/group

// 事实上，用户信息保存在passwd，密码用x代替，保存在shadow
影子口令：
用户：/etc/shadow
-rw-r----- 1 root shadow 1217 Apr  6  2017 /etc/shadow
组：/etc/gshadow
用户类别：
管理员：0
普通用户： 1-65535
    系统用户：1-499
    一般用户：500-60000

man 5 passwd
account: 登录名
password: 密码
UID：
GID：基本组ID
comment: 注释
HOME DIR：家目录
SHELL：用户的默认shell

cat /etc/shells 登录可用安全shell
# /etc/shells: valid login shells
/bin/sh
/bin/dash
/bin/bash
/bin/rbash
/usr/bin/tmux
/usr/bin/screen

/etc/shadow
account: 登录名
encrypted password: 加密的密码

用户组类别：
私有组：创建用户时，如果没有为其指定所属的组，系统会自动为其创建一个与用户名同名的组
基本组：用户的默认组
附加组，额外组：默认组以外的其它组

加密方法：
对称加密：加密和解密使用同一个密码，速度是公钥1000倍，效率快
公钥加密（非对称加密）：每个密码都成对儿出现，一个为私钥(secret key)，一个为公钥(public key)
单向加密(指纹加密)，散列加密：提取数据特征码，常用于数据完整性校验
    1、雪崩效应
    2、定长输出
        MD5：Message Digest, 信息摘要,128位定长输出
        SHA1：Secure Hash Algorithm, 160位定长输出


</pre>
<h6>md5加密</h6>
<pre>
md5sum /etc/inittab
753a386bcd9ab0ca581056348463891e  inittab
</pre>

</section>

<section class="cmd-description grid-item">
    <h4><a name="用户管理" href="#用户管理">*用户管理</a></h4>
<h6>添加用户</h6>
<pre>
默认情况下新建用户只能在home目录有操作权限, 如果手动创建的目录, 请注意要chown给予用户权限

// 添加一个用户，默认地添加到tom组
useradd tom
// 查看密码
cat /etc/shadow | grep tom
// tom:!!:17470:0:99999:7:::
// 可以看见是没有密码的，添加一个密码
passwd tom
// 查看密码和私有组
cat /etc/shadow /etc/group | grep tom


为什么会有默认值？
// 查看模板
vim /etc/default/useradd
# useradd defaults file
GROUP=100
HOME=/home
INACTIVE=-1 #密码过期可宽限天数
EXPIRE=     #没指定永不过期
SHELL=/bin/bash
SKEL=/etc/skel
CREATE_MAIL_SPOOL=yes

useradd  [options]  USERNAME 
    -u UID 大于等于500，一般和私有组gid相同
    -g GID（基本组）注意不是私有组，用户只有一个基本组，但是可以拥有多个附加组
    -G GID,...  （附加组）重点，附加组只能去/etc/group才能体现
    -c "COMMENT"
    -d /path/to/directory 重点
    -s SHELL 如/bin/bash
    // 复制/etc/skel初始化骨架，如bash_profile bashrc等，即便不带参数也会复制过去
    -m -k
    //  man这个- m参数，发现这个文件/etc/login.defs设置了密码加密算法，过期时间，uid，用户环境变量 ,必须设置家命令等等一些列默认值
    -M  这个参数一出，肯定没有家目录，可以复制/etc/skel初始化骨架
    -r: 添加系统用户 id 1-499,通常没有家目录

useradd -u 1000 user1
//添加user2,指定基本组为grp1, 附加组为grp1, 此时此刻user2的id为1001
useradd -g grp1 -G user1 user2 
id user2
tail -2 /etc/group
// user1:x:1000:user2
// grp1:x:1001:
// 禁止用户登录
useradd -s /bin/nologin user3
useradd -M nologindefs
su - nologindefs
// su: 警告：无法切换到目录/home/nologindefs: 没有那个文件或目录
// -bash-4.1$ 
// 修复此类登录问题，其实是缺少了一些默认的配置，复制/etc/skel的隐藏文件到其家目录即可


// 基本查看useradd路径
which useradd
ll $(which useradd)
ll `which useradd`
// 别名adduser
ll `which adduser`
lrwxrwxrwx. 1 root root 7  8月 17 2015 /usr/sbin/adduser -> useradd
</pre>
<h6>修改密码</h6>
<pre>
// 输入两次用户密码
passwd tom

--stdin  // 管道方式变更密码
    -l 锁定用户
    -u 解锁用户
    -d: 删除用户密码，默认是禁止空密码用户登录

shell 改变密码
echo "redhat" | passwd --stdin user1

</pre>
<h6>openssl生成安全密码</h6>
<pre>
// 输出复制密码
openssl passwd
// 查看密码相关使用手册
man sslpasswd
//  -1  Use the MD5 based BSD password algorithm 1.
// salt加密
openssl -l -salt '123456'

将上述代码复制到shadow即可手动添加密码
</pre>
<h6>修改用户</h6>
<pre>
usermod
    -u UID 
    -g GID
    -a -G GID：不使用-a选项，会覆盖此前的附加组；
    -c comment
    -d -m：变更家目录那么原本目录的数据就不能访问了，所以-m就会迁移数据到新目录
    -s shell
    -l 登录名login name ,登录用户名也变更了
    -L：锁定帐号
    -U：解锁帐号

usermod -u 2000 user1

// 为用户user1添加附加组grp2
usermod -a -G grp2 user1
</pre>
<h6>chsh 修改用户默认shell</h6>
<pre>
finger user1
chsh user1
  /bin/csh
// 默认的shell变更了
finger user1
</pre>
<h6>pwck</h6>
<pre>
密码安全隐患报告
</pre>
<h6>修改用户基础信息</h6>
<pre>
// 交互式补全用户基础信息，用户名，电话，公司等，其实就是注释信息的内容
chfn user1 
</pre>
<h6>删除用户</h6>
<pre>
注意
// 默认情况下是不会删除用户的家目录
userdel user1
// 删除家目录
userdel -r user1
</pre>
<h6>id 查看用户属性</h6>
<pre>
id user2
// uid=1001(user2) gid=1001(grp1) 组=1001(grp1),1000(user1)

// 附加组id
id -G
// 把附加组id转换成名字，n参数可以和多个id参数配合
id -Gn
</pre>
<h6>finger 用户信息，登录时间，计划任务等</h6>
<pre>
// rpm -qa | grep finger
finger user1
</pre>
</section>
<section class="cmd-description grid-item">
<h4><a name="sticky" href="#sticky">sticky</a></h4>
<pre class="prettyprint lang-php">
在一个公共目录,每个用户都可以创建文件, 删除自己的文件, 但是不能删除别人的文件
chmod o+t /dir
chmod o-t /dir
</pre>
</section>

<section class="cmd-description grid-item">
    <h4><a name="计算器" href="#计算器">计算器</a></h4>
    <h6>bc</h6>
<pre class="prettyprint lang-php">
// 保留两位小数
scale 2 
//退出    
quit

// shell 中bc计算
echo "scale=2;22/3;" | bc
等同于 bc <<< "scale=2;22/3;"
</pre>
</section>

<section class="cmd-description grid-item">
    <h4><a name="组管理" href="#组管理">组管理</a></h4>
<h6>添加组</h6>
<pre>
groupadd mygroup
  -g 指定gid
  -r 添加一个系统用户 1-499id
</pre>
<h6>修改组</h6>
<pre>
groupmod 
  -g GID
  -n GROUPNAME
</pre>
<h6>删除组</h6>
<pre>
groupdel
</pre>
<h6>组密码</h6>
<pre>
gpasswd 为组设定密码
// 应用场景，用户临时切换其他组以获得对应资源，注意原本这个组不属于该用户，否则是可以不输入密码立刻切换的
// 该命令是一种登录属性，使用exit即可退出切换组
// 为用户user1添加附加组grp2
usermod -a -G grp2 user1
newgrp mygroup

// 这个时候就要为gpasswd添加密码了
// 切换组以后创建一个文件,发现组的名称变更了为mygroup，因为基本组已经切换了
touch mygroup.txt
</pre>
</section>
<section class="cmd-description grid-item">
    <h4><a name="CPU" href="#CPU">CPU</a></h4>
<pre class="prettyprint lang-php">
CPU ：加法器，控制器
CPU主频 = 外频 * 倍频
一般说的超频说的就是外频，100MHz外频表示数字脉冲信号在每秒震荡1亿次
倍频一般给厂家锁定了
FSB前端总线，连接CPU和北桥，100Mhz前端总线和64位CPU表示 100M * 64 / 8 bit / 1s= 800MB/s的数据交换速度

机器语言（二进制）：不同芯片平台代码可能需要移植
微码（汇编语言）：微码是芯片自带的，需要编译器编译为二进制
高级语言：理论上，先编译为微码， 然后再编译为二进制
实际上： 高级语言调用汇编的库API，从而忽略芯片的差异

解析型&编译型
解析型
有专门的编译器，一遍编译一次执行，一般效率慢，移植性高
编译型
执行前需要将代码编译成机器码，一次编译永久执行

静态语言&动态语言
静态语言
数据类型在编译期间检查，也就是说写程序的时候要声明所有变量的数据类型，如C/C++, JAVA等
动态语言
运行期间才会检查数据类型的语言，也就是说永远都不需要检查语言的数据类型，如:php, python , javascript, ruby 等

强类型&弱类型
强类型
数据类型一旦定义，必须经过强转换才能改变类型，如：string 3不可能和int 3相加
弱类型
数据类型可以忽略


</pre>
 
</section>

<section class="cmd-description grid-item">
    <h4><a name="IO重定向" href="#IO重定向">IO重定向</a></h4>
    <h6>系统设定</h6>
<pre class="prettyprint lang-php">
默认输出设备：标准输出，STDOUT, 1
默认输入设备：标准输入, STDIN, 0
标准错误输出：STDERR, 2
</pre>

<h6>重定向</h6>
<pre>
>: 覆盖输出
>>：追加输出

set -C 关闭覆盖输出,禁止对已存在文件使用覆盖输出
// 禁用强制开启,|。如：echo test >| test.log

set +C 开启关闭覆盖输出

2> 错误重定向输出
2>>追加错误重定向输出

&> 重定向正常输出和错误输出
&>> 追加重定向


<  输入重定向
<< heredoc
// 大多数这种命令就是输入重定向
cat < /etc/fstab
// 交互式输入转换大小写，输入重定向后变为直接转换
tr 'a-z' 'A-z' < /etc/fstab

输入输出重定向，脚本中经常使用
cat >> 2017-08.log << EOF
>abc
>EOF
</pre>
</section>


<section class="cmd-description grid-item">
    <h4><a name="shell编程" href="#shell编程">shell编程</a></h4>
脚本在执行时会启动一个子shell进程；
    命令行中启动的脚本会继承当前shell环境变量；
    系统自动执行的脚本(非命令行启动)就需要自我定义需要各环境变量；

<h6>本地变量</h6>
<pre class="prettyprint lang-php">
// 引用变量, 大花括号， ${VAR_NAME}, 大多数时候可以省略
// 双引号弱引用，内部的变量会引用
// 单引号强引用，内部变量不会引用
// 本地变量仅用于当前bash
# name=peter
# echo $name 
# echo "my name is $name"
// 区分变量  
# echo "my name is ${name}wu"  //my name is peterwu
// 本地变量
#  echo 'my name is ${name}wu' //my name is ${name}wu

</pre>
<h6>局部变量</h6>
<pre>
紧作用于当前代码段
local var_name=test
</pre>
<h6>环境变量</h6>
<pre>
// 导出环境变量
export VARNAME=VALUE

// 原本变量作用域只能存在于当前的shell,export变量使其可以切换bash后保持变量
name=peter
export name
bash 
echo $name
</pre>
<h6>位置变量</h6>
<pre>
// 获取脚本运行参数值
$1,$2,$3
</pre>

<h6>特殊变量</h6>
<pre>
$?: 上一个命令的执行状态返回值；
$#：参数的个数
$*: 参数列表
$@：参数列表

程序执行，可能有两类返回值：
    程序执行结果
    程序状态返回代码（0-255）
        0: 正确执行
        1-255：错误执行，1，2，127系统预留；
</pre>

<h6>变量重新赋值</h6>
<pre>
# PERSON=peter
# PERSON=$PERSON:10
// result: peter:10
# echo $PERSON
// 环境变量添加路径
# PATH=$PATH:/tmp
</pre>

<h6>shebang魔数</h6>
<pre>
#!/bin/shell
</pre>
<h6>运算</h6>
A=2
B=3
C=$A+$B
echo $C // 2+3 字符串
<h6>输出重定向</h6>
<pre>
/dev/null: 软件设备， bit bucket，数据黑洞    
>
>>
2>
2>>
&>

// 判断用户是否存在
id student &> /dev/null
echo $?
</pre>
<h6>删除变量</h6>
<pre>
// 撤销变量，而不是变量的值
unset name
</pre>
<h6>查看变量</h6>
<pre>
// shell中的变量
set
// shell中的环境变量
printenv
env
export
</pre>
<h6>自动展开</h6>
<pre>
echo {1..4} // 等同于seq
mkdir -p /tmp/{1,b,c,d}
</pre>
<h6>seq</h6>
<pre>
seq 4 // 1 2 3 4
seq 2 4 // 2 3 4
seq 2 2 10 // 2 4 6 8 10
seq 1 2 10 // 1 3 5 7 9
</pre>
</section>
                </div>
            </div>
        </div>
    </div>
</div>
</div>
<script src="assets/js2/jquery.js"></script>
<script src="assets/js2/jquery.highlight-4.js"></script>
<script src="assets/js2/google-code-prettify/prettify.js"></script>
<script src="assets/js2/foundation.min.js"></script>
<script src="assets/js2/masonry.js"></script>
<script src="assets/js2/app.js"></script>

<script>
    (function (i, s, o, g, r, a, m) {
        i['GoogleAnalyticsObject'] = r;
        i[r] = i[r] || function () {
                (i[r].q = i[r].q || []).push(arguments)
            }, i[r].l = 1 * new Date();
        a = s.createElement(o),
            m = s.getElementsByTagName(o)[0];
        a.async = 1;
        a.src = g;
        m.parentNode.insertBefore(a, m)
    })(window, document, 'script', '//www.google-analytics.com/analytics.js', 'ga');

    ga('create', 'gaTrackingID', 'auto');
    ga('send', 'pageview');

</script>
</body>
</html>
